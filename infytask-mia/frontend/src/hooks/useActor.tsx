
import { useState, useEffect } from 'react';
import { useInternetIdentity } from './useInternetIdentity';
import * as Types from '../backend';

export function useActor() {
    const { identity, isAuthenticated } = useInternetIdentity();
    const [isFetching, setIsFetching] = useState(false);

    const mockActor = {
        getAllProjects: async () => [] as Types.Project[],
        getAllTasks: async () => [] as Types.Task[],
        getProject: async (id: string) => ({ id, name: 'Mock Project', description: 'Mock Description' } as any),
        getTask: async (id: string) => ({ id, name: 'Mock Task', description: 'Mock Description', state: 'new' } as any),
        createProject: async (id: string, name: string, description: string) => ({ id, name, description } as any),
        createTask: async (id: string, projectId: string, name: string, description: string) => ({ id, projectId, name, description } as any),
        updateProject: async (id: string, name: string, description: string) => ({ id, name, description } as any),
        updateTask: async (id: string, name: string, description: string, state: Types.TaskState) => ({ id, name, description, state } as any),
        archiveProject: async (id: string) => true,
        restoreProject: async (id: string) => true,
        archiveTask: async (id: string) => true,
        restoreTask: async (id: string) => true,
        searchProjects: async (term: string) => [] as Types.Project[],
        searchTasks: async (term: string) => [] as Types.Task[],
        getAllModuleMappings: async () => [] as Types.ModuleMapping[],
        addModuleMapping: async (name: string, char: string) => true,
        getApiSpec: async (name: string) => '',
        addApiSpec: async (name: string, spec: string) => true,
        getCallerUserProfile: async () => ({ id: '1', username: 'Admin', role: 'Admin' } as Types.UserProfile),
        saveCallerUserProfile: async (profile: Types.UserProfile) => profile,
        getCallerUserRole: async () => 'Admin' as Types.UserRole,
        isCallerAdmin: async () => true,
        isCallerApproved: async () => true,
        updateTaskState: async (id: string, state: Types.TaskState) => true,
        deleteTasks: async (ids: string[]) => true,
        getDemoData: async () => ({ projects: [], tasks: [], suggestions: [] }),
        openTab: async (id: string, name: string, type: Types.TabType, resourceId: string, is3D: boolean) => true,
        closeTab: async (resourceId: string) => true,
        getOpenTabs: async () => [] as Types.Tab[],
        getActiveProjectCount: async () => BigInt(0),
        addNotification: async (id: string, message: string, type: Types.NotificationType) => true,
        markNotificationAsRead: async (message: string) => true,
        getNotifications: async () => [] as Types.Notification[],
        updateFeatureStatus: async (id: string, name: string, status: Types.FeatureState) => true,
        getFeatureStatuses: async () => [] as Types.FeatureStatus[],
        getSitemap: async () => [] as Types.SitemapNode[],
        storeSecureData: async (id: string, data: string) => true,
        requestPermission: async (dataId: string) => true,
        approvePermissionRequest: async (requestId: string) => true,
        rejectPermissionRequest: async (requestId: string) => true,
        getAllSecureData: async () => [] as Types.SecureData[],
        getPermissionRequests: async () => [] as Types.PermissionRequest[],
        validateSchema: async (id: string, schema: string) => true,
        getSchemaValidation: async (id: string) => ({ id, schema: '', status: true, errors: [], validatedAt: BigInt(0) } as Types.SchemaValidation),
        getAllSchemaValidations: async () => [] as Types.SchemaValidation[],
        logManifestChange: async (id: string, changes: string[], version: bigint, validationStatus: boolean) => true,
        getManifestLog: async (id: string) => ({ id, changes: [], version: BigInt(0), validationStatus: true, timestamp: BigInt(0) } as Types.ManifestLog),
        getAllManifestLogs: async () => [] as Types.ManifestLog[],
        addYamlSchema: async (id: string, content: string, isNormalized: boolean, validationStatus: boolean) => true,
        getYamlSchema: async (id: string) => ({ id, content: '', isNormalized: true, validationStatus: true, updatedAt: BigInt(0) } as Types.YamlSchema),
        getAllYamlSchemas: async () => [] as Types.YamlSchema[],
        addFeatureVerification: async (id: string, name: string, aiVerified: boolean, adminApproved: boolean, status: Types.FeatureState, fixtureTopic: string, fof: string) => true,
        getFeatureVerification: async (id: string) => ({ id, name: '', aiVerified: true, adminApproved: true, status: 'completed', fixtureTopic: '', fof: '' } as Types.FeatureVerification),
        getAllFeatureVerifications: async () => [] as Types.FeatureVerification[],
        addFixture: async (id: string, topic: string, fof: string, status: Types.FixtureStatus) => true,
        getFixture: async (id: string) => ({ id, topic: '', fof: '', status: 'active', aiDecision: '', adminDecision: '' } as Types.Fixture),
        getAllFixtures: async () => [] as Types.Fixture[],
        addExecutionLog: async (timestamp: bigint, actor: string, action: string, signature: string) => true,
        getExecutionLog: async (timestamp: any) => ({ timestamp: BigInt(0), actor: '', action: '', signature: '' } as Types.ExecutionLog),
        getAllExecutionLogs: async () => [] as Types.ExecutionLog[],
        addAiImport: async (id: string, type: Types.ImportType, patch: string, status: Types.ImportStatus) => true,
        getAiImport: async (id: string) => ({ id, type: 'spec.ml', patch: '', status: 'pending', createdAt: BigInt(0) } as Types.AiImport),
        getAllAiImports: async () => [] as Types.AiImport[],
        addSphereNode: async (id: string, type: string, color: string, position: any) => true,
        removeSphereNode: async (id: string) => true,
        getAllFormTemplates: async () => [] as Types.FormTemplate[],
        getFormTemplate: async (id: string) => ({ id, name: '', formData: '', metadata: '', eContractDetails: '' } as Types.FormTemplate),
        createFormTemplate: async (id: string, name: string, formContent: string, metadata: string, detailsOfEContracts: Types.PostcardContent[]) => true,
        updateFormTemplate: async (id: string, name: string, formContent: string, metadata: string, detailsOfEContracts: Types.PostcardContent[]) => true,
        bulkImportMdFiles: async (mdFiles: any) => true,
        getAllNodeTypes: async () => [] as Types.NodeType[],
        getNodeType: async (id: string) => ({ id, type: 'notes/text', color: '' } as Types.NodeType),
        createNodeType: async (id: string, name: string, color: string, description: string) => true,
        updateNodeType: async (id: string, name: string, color: string, description: string) => true,
        deleteNodeType: async (id: string) => true,
        searchNodesByColor: async (color: string) => [] as Types.NodeType[],
        getAllNodeLinks: async () => [] as Types.NodeLink[],
        getLinksForNode: async (id: string) => [] as Types.NodeLink[],
        getBacklinksForNode: async (id: string) => [] as Types.NodeLink[],
        createNodeLink: async (id: string, source: string, target: string, type: Types.LinkType, strength: number) => true,
        updateNodeLink: async (id: string, source: string, target: string, type: Types.LinkType, strength: number) => true,
        deleteNodeLink: async (id: string) => true,
        deduplicateSpecMd: async (id?: string) => ({ entriesCleaned: 0, timestamp: BigInt(0) } as Types.DeduplicationResult),
        getDeduplicationResult: async (timestamp: any) => ({ entriesCleaned: 0, timestamp: BigInt(0) } as Types.DeduplicationResult),
        getAllDeduplicationResults: async () => [] as Types.DeduplicationResult[],
        getLatestDeduplicationResult: async () => ({ entriesCleaned: 0, timestamp: BigInt(0) } as Types.DeduplicationResult),
        getDeduplicationStatus: async () => ({ totalDeduplicationRuns: BigInt(0), lastRunTimestamp: BigInt(0), averageCompressionRatio: 0, totalEntriesCleaned: BigInt(0) }),
        normalizeSpecContent: async (content: string) => content,
        recompressSpecFile: async (target: any) => ({ target, beforeSize: BigInt(0), afterSize: BigInt(0), ratio: 0, timestamp: BigInt(0) } as Types.CompressionMetric),
        refreshSchemaAfterDedup: async (id: string) => true,
    };

    return { actor: isAuthenticated ? mockActor : null, isFetching };
}

import { BackendActor, SpecFormat, Theme, FileType, SubscriptionStatus, FileUploadStatus } from '../backend';

export function useActor() {
    const mockActor: BackendActor = {
        initializeAccessControl: async () => { },
        getCallerUserRole: async () => ({ user: null }),
        assignCallerUserRole: async () => { },
        isCallerAdmin: async () => false,
        getCallerUserProfile: async () => null,
        getUserProfile: async () => null,
        saveCallerUserProfile: async () => { },
        addSubscription: async () => { },
        getUserSubscription: async () => null,
        updateSubscription: async () => { },
        isCallerSubscriber: async () => false,
        getCurrentSpec: async () => ({
            timestamp: BigInt(Date.now() * 1000000),
            content: "title: Mock Specification\ndescription: This is a reconstructed mock specification for testing.",
            format: SpecFormat.yaml
        }),
        updateSpec: async () => { },
        getSpecHistory: async () => [],
        revertToVersion: async () => { },
        validateSpecFormat: async () => true,
        addSitemapEntry: async () => { },
        getSitemap: async () => [],
        searchSitemap: async () => [],
        removeSitemapEntry: async () => { },
        toggleTheme: async () => Theme.default,
        getCurrentTheme: async () => Theme.default,
        addFileMetadata: async () => { },
        updateUploadProgress: async () => { },
        validateFilePairing: async () => true,
        affirmFilePairing: async () => { },
        getAllFilePairs: async () => [],
        getPairingErrors: async () => [],
        paginateFiles: async () => ({ items: [], pagination: { page: 0n, pageSize: 10n, totalItems: 0n, totalPages: 0n } }),
        maskHash: async (h) => h,
        addPage: async () => { },
        getAllPages: async () => [],
        getPage: async () => null,
        removePage: async () => { },
        updatePage: async () => { },
        initializeDefaultPages: async () => { },
        getNavigationLinks: async () => [],
        getAdminNavigationLinks: async () => [],
        getQuickLinks: async () => [],
        getBottomNavbarLinks: async () => [],
        validateNavigationLinks: async () => true,
        markFeatureAsCompleted: async () => { },
        getBusinessInfo: async () => ({} as any),
        updateBusinessInfo: async () => { },
        validateBusinessInfo: async () => true,
        addManifestEntry: async () => { },
        getManifestLog: async () => [],
        filterManifestLogByAction: async () => [],
        createBackup: async () => ({} as any),
        restoreBackup: async () => { },
        getAnalyticsData: async () => ({ totalUsers: 0n, totalFiles: 0n, totalContracts: 0n, activeUsers: 0n, revenue: 0n }),
        isStripeConfigured: async () => false,
        setStripeConfiguration: async () => { },
        getStripeConfiguration: async () => null,
        getStripeSessionStatus: async () => ({ failed: { error: "Not implemented" } }),
        createCheckoutSession: async () => "",
        addReferral: async () => { },
        getUserReferrals: async () => [],
        updateReferralStatus: async () => { },
        addTemplateInteraction: async () => { },
        getUserTemplateInteractions: async () => [],
        getTemplateInteractionsByTemplateId: async () => [],
        hasEnhancedTemplateAccess: async () => false,
        downloadTemplate: async () => null,
        addManualPage: async () => { },
        getManualPages: async () => [],
        getPageByPath: async () => null,
        updateManualPage: async () => { },
        removeManualPage: async () => { },
        addControlledRoute: async () => { },
        getControlledRoutes: async () => [],
        getControlledRouteByPath: async () => null,
        updateControlledRoute: async () => { },
        removeControlledRoute: async () => { },
        resolveSitemap: async () => ({ auto: [], manualPages: [], controlledRoutes: [] }),
        getSystemPages: async () => [],
        getAdminControlledRoutes: async () => [],
    };

    return { actor: mockActor, isFetching: false };
}
